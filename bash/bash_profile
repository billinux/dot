#!/bin/bash

# http://www.bordel-de-nerd.net/2010/08/configurer-son-terminal-bash/#content

# bash_profile
#$HOME/.rvm/scripts/rvm

declare -a files=(
    $HOME/.rvm/scripts/rvm # Load RVM into a shell session *as a function*
    $HOME/.dotfiles/bash/bash_colors # Colors
    $HOME/.dotfiles/bash/bash_options # Options
    $HOME/.dotfiles/bash/bash_exports # Exports
    $HOME/.dotfiles/bash/bash_prompt # Custom bash prompt
    $HOME/.dotfiles/bash/bash_aliases # Aliases
    $HOME/.dotfiles/bash/functions/*/* # Functions
    $HOME/.bash_profile.local # Local and private settings not under version control (e.g. git credentials)
    $HOME/.dotfiles/bash/bash_paths # Path modifications (must source after `.bash_profile.local` in case of custom `brew` location)
)

# If these files are readable, source them
for index in ${!files[*]}
do
    if [[ -r ${files[$index]} ]]; then
        source ${files[$index]}
    fi
done

unset files


# Add tab completion for SSH hostnames based on ~/.ssh/config, ignoring wildcards
[ -e "$HOME/.ssh/config" ] && complete -o "default" -o "nospace" -W "$(grep "^Host" ~/.ssh/config | grep -v "[?*]" | cut -d " " -f2 | tr ' ' '\n')" scp sftp ssh

# Add `killall` tab completion for common apps
complete -o "nospace" -W "Contacts Calendar Dock Finder Mail Safari iTunes SystemUIServer Terminal Twitter" killall

# Autocomplete Grunt commands
which grunt > /dev/null && eval "$(grunt --completion=bash)"


# Enable bash completion in interactive shells
if [ -f /etc/bash_completion ] && ! shopt -oq posix; then
  . /etc/bash_completion
fi


# Complétion pour les noms d’hôte ssh
if [ -f ~/.ssh/known_hosts ]; then
    SSH_COMPLETE=( $(cat ~/.ssh/known_hosts | \
    cut -f 1 -d ' ' | \
    sed -e s/,.*//g | \
    uniq | \
    egrep -v [0123456789]) )
    complete -o default -W "${SSH_COMPLETE[*]}" ssh
fi

# Complétion fonctionne aussi avec sudo
complete -cf sudo

# Utiliser [Tab] et [Ctrl]-r avec kingbash
# https://aur.archlinux.org/packages/kingbash/

#OK=false
OK=false

if [ -x ~/.dotfiles/bin/kingbash ] && ${OK} ; then
    case "$-" in #to avoid that this command line is used in interactive shells
        *i*)
            bind -x '"\t":out=$(kingbash.script "$PS1" "$(compgen -A alias -A function)" nohelp); READLINE_LINE=$(echo "$out" | head -n -1); READLINE_POINT=$(echo "$out" | tail -n 1)'
    esac
fi

# Enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
  test -r /etc/dircolors && eval "$(dircolors -b /etc/dircolors)" || eval "$(dircolors -b)"
fi

